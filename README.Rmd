---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# clust431

<!-- badges: start -->
<!-- badges: end -->

The goal of clust431 is to ...

## Installation

You can install the released version of clust431 from [CRAN](https://CRAN.R-project.org) with:

```{r example}
library(clust431)
library(tidyverse)
library(dplyr)
## basic example code
```





#kmeans examples using lloyd method
```{r}
set.seed(123)
k_means(mtcars, 3)
```
#compared to base kmeans

```{r}
set.seed(123)
kmeans(mtcars,3, algorithm = "Lloyd")$cluster
kmeans(mtcars, 3, algorithm = "Lloyd")$totss
```

We get the same cluster assignments and fairly similar total_SS


using k_means with pca
```{r}
k_means(mtcars, 3, pca=T)
```

here is my function

#' Implements a very basic k means algorithm using Lloyd's algorithm
#'
#' @param dat A dataset
#' @param k Number of cluster
#' @param pca default=F If true, automatically performs a PCA before doing k means clustering

#'
#' @return Cluster assignments, TOTSS, and a dataframe of cluster means
#'
#' @import dplyr
#' @export
#'
#'
k_means<- function(dat, K, pca=F) {

    #Write one function called k_means() that implements a very basic k-means algorithm.
    #Choose k random observations in the data as your starting points.
    #Do not do any fancy adjustments to balance cluster sizes and so forth.
    #Include an option in k_means() to automatically perform PCA before doing the k_means() clustering, using only the first 2 dimensions. (You may use built-in functions like princomp() for this.)
    #At a minimum, your function should output the cluster assignments and total sum of squares.

    if (isTRUE(pca)){

      pca_df = prcomp(dat, center = TRUE, scale = TRUE)

        X = as.matrix(pca_df$x[,1:2])
    }
    else{X=as.matrix(dat)}


    initialCentroids<-matrix(0,K,ncol(X))
    centroids<-X[sample(1:nrow(X),K),]
    set<-rep(0, K)
    Cluster<-rep(0, nrow(X))

    converged=F
    while(converged==F) {

         for(i in 1:dim(X)[1]){

               for(j in 1:dim(centroids)[1]){

                set[j]=(X[i,]-centroids[j,])%*%(X[i,]-centroids[j,]);
               }

            Cluster[i]=which.min(set);
        }

        initialCentroids=centroids;

        for(k in 1:K){
            centroids[k,]=colMeans(X[which(Cluster==k),]);
        }
        if (isTRUE(all.equal(centroids, initialCentroids))) {converged=T}
        else{converged=F}

    }
    #print(Cluster)
    obs<-dat
    sstotal<-sum((obs-centroids)^2)
    print(sstotal)
    results<-data.frame(rbind("clusters"=Cluster))
    colnames(results)<-rownames(dat)
    return(results)
}


#hier_clust

```{r}
hier_clust(mtcars, 4)

```


#hclust

```{r}
set.seed(123)
mtdist<-dist(mtcars)
cutree(hclust(mtdist, method="single"), 4)
```


#' Implements a very basic single linkage hclust algorithm, return the same value as  cutree(hclust(dist(dat), method="single"), k=k)
#'
#' @param dat A dataset and desired number of cluster
#' @param k An integer to select desired number of clusters
#'
#'
#' @return Cluster assignments
#'
#' @import dplyr
#' @export
#'
#'

hier_clust<- function(dat, k){
N <- nrow(dat)
distMAT<- as.matrix(dist(dat))


 rownames(distMAT) <- -(1:N)
 colnames(distMAT) <- -(1:N)


 merge <- matrix(0, N-1, ncol=2)
 height <- rep(0,N-1)

 for (i in 1:(N-1)) {
     diag(distMAT) <- Inf
     cols <- colnames(distMAT)

     minD <- which(distMAT == min(distMAT), arr.ind = TRUE)[1,,drop=FALSE]

     height[i] <- min(distMAT)
     merge[i,] <- as.numeric(cols[minD])

     clusters <- c(minD, which(cols %in% cols[minD[1, cols[minD] > 0]]))
     colnames(distMAT)[clusters] <- i

     pairs <- apply(distMAT[minD,], 2, min)    #single linkage  method:mininum
     distMAT[,min(minD)] <- pairs
     distMAT[min(minD),] <- pairs


     diag(distMAT) <- Inf
     distMAT[,max(minD)] <- Inf
     distMAT[max(minD),] <- Inf

 }
 merge<-Thermimage::mirror.matrix(merge)

 res <- list("merged"=merge,"height"=height,"clusters"=clusters, "labels"=rownames(dat))
 cutree(res, k)



}

